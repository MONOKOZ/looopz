<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1DB954">
    <title>LOOOPZ - Create Viral Music Loops from Spotify</title>
    <meta property="og:title" content="LOOOPZ - Create Viral Music Loops">
    <meta property="og:description" content="Create perfect loops from any Spotify track. Precision timing. Endless possibilities.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://looopz.vercel.app/">
    <meta property="og:image" content="https://looopz.vercel.app/og-image.png">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='40' fill='none' stroke='%231DB954' stroke-width='6'/%3E%3Ccircle cx='50' cy='50' r='25' fill='none' stroke='%231DB954' stroke-width='4'/%3E%3Ccircle cx='50' cy='50' r='10' fill='%231DB954'/%3E%3C/svg%3E">

    <style>
:root {
    --primary: #1DB954;
    --secondary: #9945DB;
    --dark: #0a0a0a;
    --medium: #1a1a1a;
    --light: #FFFFFF;
    --gray: #2a2a2a;
    --light-gray: #b3b3b3;
    --danger: #c0392b;
    --gradient: linear-gradient(135deg, var(--primary), var(--secondary));
}

* {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
    background: var(--dark);
    color: var(--light);
    margin: 0;
    padding: 0;
    line-height: 1.5;
    overflow-x: hidden;
    min-height: 100vh;
    touch-action: pan-y;
    overscroll-behavior: none;
}

.app-header {
    background: rgba(26, 26, 26, 0.95);
    backdrop-filter: blur(20px);
    padding: 12px 20px;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    box-shadow: 0 1px 20px rgba(0, 0, 0, 0.3);
    border-bottom: 1px solid rgba(255, 255, 255, 0.04);
}

.header-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 600px;
    margin: 0 auto;
}

.logo {
    font-size: 24px;
    font-weight: 800;
    color: white;
    letter-spacing: -0.5px;
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
    color: var(--light-gray);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.connection-status.show {
    opacity: 1;
}

.status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--primary);
    animation: pulse 2s infinite;
}

.disconnect-btn {
    background: var(--danger);
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 10px;
    cursor: pointer;
    margin-left: 4px;
}

.main-container {
    padding: 80px 8px 120px;
    max-width: 600px;
    margin: 0 auto;
    min-height: 100vh;
}

.card {
    background: linear-gradient(145deg, var(--medium), rgba(42, 42, 42, 0.3));
    border: 1px solid rgba(255, 255, 255, 0.03);
    border-radius: 20px;
    padding: 21px;
    margin-bottom: 24px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
}

.card-title {
    color: var(--light);
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 16px 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.btn {
    background: var(--gradient);
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 50px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    min-height: 44px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    box-shadow: 0 2px 12px rgba(29, 185, 84, 0.15);
    transition: all 0.3s ease;
}

.btn:hover { background: linear-gradient(135deg, #1ed760, #a855f7); transform: translateY(-2px); }
.btn:active { transform: scale(0.98); }
.btn.secondary { background: linear-gradient(135deg, var(--secondary), #7a3db8); }
.btn.danger { background: linear-gradient(135deg, var(--danger), #a02e20); }
.btn:disabled { background: #444; cursor: not-allowed; transform: none; }

.search-container {
    position: sticky;
    top: 41px;
    z-index: 90;
    padding: 20px 0;
    margin: -24px -24px 20px -24px;
}

.search-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 20px;
}

.back-btn {
    background: var(--gray);
    color: var(--light);
    border: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 18px;
    transition: all 0.3s ease;
}

.back-btn:hover {
    background: var(--primary);
    transform: scale(1.05);
}

.search-input {
    width: 100%;
    padding: 16px 20px;
    background: var(--dark);
    border: 2px solid transparent;
    border-radius: 50px;
    color: white;
    font-size: 21px;
    outline: none;
    margin: 10px 16px;
}

.search-input:focus {
    border-color: var(--primary);
    box-shadow: 0 0 0 4px rgba(29, 185, 84, 0.08);
}

.track-item {
    display: flex;
    align-items: center;
    padding: 12px;
    margin-bottom: 12px;
    background: var(--gray);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid transparent;
}

.track-item:hover { background: rgba(42, 42, 42, 0.8); transform: translateX(4px); }
.track-item.selected { background: rgba(29, 185, 84, 0.1); border-color: rgba(29, 185, 84, 0.4); }
.track-item.playing { background: rgba(29, 185, 84, 0.15); border-color: var(--primary); }
.track-item.playing .track-name { color: var(--primary); font-weight: 600; }

.track-cover {
    width: 48px;
    height: 48px;
    border-radius: 6px;
    margin-right: 12px;
    object-fit: cover;
}

.track-info {
    flex: 1;
    min-width: 0;
}

.track-name {
    font-weight: 500;
    font-size: 14px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 2px;
}

.track-artist {
    color: var(--light-gray);
    font-size: 13px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.track-duration {
    color: var(--light-gray);
    font-size: 12px;
    font-family: monospace;
    margin-right: 12px;
}

.track-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.track-item:hover .track-actions { opacity: 1; }

.track-action-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 8px;
    border-radius: 50%;
    font-size: 12px;
    cursor: pointer;
    font-weight: 500;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.track-action-btn.secondary { background: var(--secondary); }

.load-more-btn {
    width: 100%;
    background: linear-gradient(145deg, var(--gray), rgba(42, 42, 42, 0.8));
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: var(--light);
    padding: 16px;
    border-radius: 12px;
    font-size: 14px;
    cursor: pointer;
    margin-top: 16px;
    transition: all 0.3s ease;
}

.load-more-btn:hover {
    background: linear-gradient(145deg, #444, #333);
    transform: translateY(-2px);
}

.now-playing {
    text-align: center;
    margin-bottom: 20px;
}

.current-track {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 4px;
}

.current-artist {
    color: var(--light-gray);
    font-size: 15px;
}

.now-playing-indicator {
    position: fixed;
    top: 70px;
    right: 20px;
    background: rgba(29, 185, 84, 0.95);
    backdrop-filter: blur(10px);
    color: white;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 500;
    z-index: 90;
    opacity: 0;
    transform: translateX(100%);
    transition: all 0.3s ease;
    max-width: 200px;
}

.now-playing-indicator.show { opacity: 1; transform: translateX(0); }

.progress-container {
    height: 16px;
    background: rgba(255, 255, 255, 0.08);
    border-radius: 8px;
    position: relative;
    margin: 24px 0;
    cursor: pointer;
    overflow: visible;
    touch-action: none;
}

.progress-container:hover { height: 32px; }

.progress-bar {
    height: 100%;
    background: var(--gradient);
    border-radius: 8px;
    width: 0%;
    transition: width 0.1s linear;
    touch-action: none;
}

.loop-region {
    position: absolute;
    top: 0;
    height: 100%;
    background: rgba(29, 185, 84, 0.25);
    border-radius: 4px;
    pointer-events: none;
    border: 2px solid rgba(29, 185, 84, 0.6);
    z-index: 2;
}

.loop-handle {
    position: absolute;
    top: 50%;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: grab;
    transform: translateY(-50%);
    z-index: 15;
    border: 3px solid white;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
    opacity: 0;
    touch-action: none;
    transition: all 0.2s ease;
}

.progress-container:hover .loop-handle,
.loop-handle.dragging { opacity: 1; }

.loop-handle.dragging { cursor: grabbing; width: 32px; height: 32px; }

.loop-handle.start {
    background: var(--primary);
    left: 0;
    transform: translateX(-50%) translateY(-50%);
}

.loop-handle.end {
    background: var(--secondary);
    right: 0;
    transform: translateX(-50%) translateY(-50%);
}

.time-popup {
    position: absolute;
    bottom: 200%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.95);
    color: white;
    padding: 12px 20px;
    border-radius: 12px;
    font-size: 16px;
    font-family: monospace;
    font-weight: 600;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 100;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

.time-popup.show { opacity: 1; }

.time-display {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    color: var(--light-gray);
    margin-bottom: 16px;
    font-family: monospace;
}

.main-controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin: 16px 0;
}

.playback-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 16px;
}

.control-btn {
    background: linear-gradient(145deg, var(--gray), rgba(42, 42, 42, 0.8));
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: var(--light);
    width: 56px;
    height: 56px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.control-btn:hover { background: linear-gradient(145deg, #444, #333); transform: scale(1.05); }

.play-pause-btn {
    width: 72px;
    height: 72px;
    background: var(--gradient);
    font-size: 32px;
    border: none;
    box-shadow: 0 4px 20px rgba(29, 185, 84, 0.2);
}

.loop-controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 16px;
    background: rgba(255, 255, 255, 0.02);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.04);
}

.loop-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.toggle-switch {
    position: relative;
    width: 54px;
    height: 28px;
}

.toggle-switch input { opacity: 0; width: 0; height: 0; }

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #444;
    transition: 0.3s;
    border-radius: 28px;
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 20px;
    width: 20px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
}

input:checked + .toggle-slider { background: var(--gradient); }
input:checked + .toggle-slider:before { transform: translateX(26px); }

.loop-actions {
    display: flex;
    gap: 12px;
}

.start-loop-btn { flex: 1; }

.repeat-counter {
    display: flex;
    align-items: center;
    background: var(--gray);
    border-radius: 50px;
    padding: 6px 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
}

.repeat-btn {
    cursor: pointer;
    padding: 6px 10px;
    border-radius: 50px;
    user-select: none;
    font-weight: 500;
}

.repeat-btn:hover { background: rgba(255, 255, 255, 0.1); color: var(--primary); }

.repeat-value {
    padding: 0 12px;
    font-family: monospace;
    color: var(--primary);
    min-width: 32px;
    text-align: center;
    font-weight: 500;
}



.precision-inputs {
    padding: 0 20px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-bottom: 20px;
}

.precision-field {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.precision-label {
    font-size: 12px;
    color: var(--light-gray);
    text-transform: uppercase;
    font-weight: 600;
    letter-spacing: 0.5px;
}

.precision-input {
    background: var(--gray);
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-family: monospace;
    min-height: 44px;
    max-width: 140px;
    width: 100%;
}

.precision-input:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(29, 185, 84, 0.08);
}

.precision-popup {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(10, 10, 10, 0.65);
    backdrop-filter: blur(1px);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.precision-popup-content {
    background: linear-gradient(15deg, var(--dark), rgba(42, 42, 42, 0.85));
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 20px;
    padding: 24px;
    max-width: 500px;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

.precision-popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.precision-popup-header h3 {
    color: var(--light);
    font-size: 18px;
    font-weight: 600;
    margin: 0;
}

.popup-close {
    background: none;
    border: none;
    color: var(--light-gray);
    font-size: 20px;
    cursor: pointer;
    padding: 4px;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.popup-close:hover {
    background: rgba(255, 255, 255, 0.1);
    color: var(--light);
}

.fine-tune-section {
    padding: 0 20px 20px;
}

.fine-tune-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-bottom: 16px;
}

.fine-tune-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.fine-tune-title {
    font-size: 12px;
    color: var(--light-gray);
    text-transform: uppercase;
    font-weight: 600;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
}

.fine-tune-row {
    display: flex;
    gap: 4px;
}

.fine-tune-btn {
    background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.06);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 10px;
    cursor: pointer;
    font-family: monospace;
    font-weight: 500;
    min-height: 32px;
    flex: 1;
    user-select: none;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.fine-tune-btn:hover {
    background: linear-gradient(145deg, var(--primary), #1ed760);
    transform: translateY(-1px);
}

.fine-tune-btn.active {
    background: linear-gradient(145deg, var(--primary), #1ed760);
}

.status-bar {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(10px);
    color: white;
    padding: 10px 20px;
    border-radius: 50px;
    font-size: 13px;
    z-index: 200;
    opacity: 0;
    transition: all 0.3s ease;
    max-width: 90%;
    border: 1px solid rgba(255, 255, 255, 0.08);
    font-weight: 500;
}

.status-bar.show { opacity: 1; transform: translateX(-50%) translateY(-5px); }

.mobile-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(26, 26, 26, 0.98);
    backdrop-filter: blur(20px);
    padding: 8px 0 calc(8px + env(safe-area-inset-bottom));
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.3);
    z-index: 99;
    border-top: 1px solid rgba(255, 255, 255, 0.06);
}

.nav-container {
    display: flex;
    justify-content: space-around;
    align-items: center;
    max-width: 600px;
    margin: 0 auto;
    padding: 0 20px;
}

.nav-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    background: none;
    border: none;
    color: var(--light-gray);
    cursor: pointer;
    padding: 10px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 500;
    min-width: 70px;
    position: relative;
}

.nav-btn:hover { color: var(--light); background: rgba(255, 255, 255, 0.04); }
.nav-btn.active { color: var(--primary); }

.nav-icon { font-size: 18px; }
.nav-label { font-size: 10px; font-weight: 600; }

.loop-count-badge {
    background: var(--primary);
    color: white;
    font-size: 8px;
    font-weight: 700;
    padding: 1px 4px;
    border-radius: 8px;
    position: absolute;
    top: 6px;
    right: 10px;
    display: none;
}

.login-screen {
    text-align: center;
    padding: 40px 20px;
    max-width: 500px;
    margin: 0 auto;
}

.login-icon {
    font-size: 60px;
    margin-bottom: 20px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: float 3s ease-in-out infinite;
}

.login-title {
    font-size: 26px;
    font-weight: 700;
    margin-bottom: 12px;
    background: var(--gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.login-subtitle {
    color: var(--light-gray);
    font-size: 15px;
    margin-bottom: 32px;
    line-height: 1.5;
}

.saved-loop {
    background: linear-gradient(145deg, rgba(42, 42, 42, 0.5), rgba(26, 26, 26, 0.5));
    border: 1px solid rgba(255, 255, 255, 0.04);
    border-radius: 16px;
    padding: 18px;
    margin-bottom: 12px;
    transition: all 0.3s ease;
}

.saved-loop:hover { transform: translateY(-2px); border-color: rgba(29, 185, 84, 0.2); }
.saved-loop.playing { border-color: var(--primary); background: linear-gradient(145deg, rgba(29, 185, 84, 0.08), rgba(29, 185, 84, 0.03)); }

.loop-header {
    display: flex;
    align-items: center;
    gap: 14px;
    margin-bottom: 14px;
}

.loop-thumbnail {
    width: 56px;
    height: 56px;
    border-radius: 10px;
    object-fit: cover;
    flex-shrink: 0;
}

.loop-details { flex: 1; }

.loop-track-name {
    font-weight: 500;
    font-size: 15px;
    margin-bottom: 2px;
    color: var(--light);
}

.loop-artist {
    color: var(--light-gray);
    font-size: 13px;
}

.loop-stats {
    display: flex;
    gap: 16px;
    margin-bottom: 14px;
    font-size: 12px;
}

.loop-stat {
    display: flex;
    align-items: center;
    gap: 4px;
    color: var(--light-gray);
}

.loop-stat-icon {
    color: var(--primary);
    font-size: 11px;
}

.loop-actions {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}

.loop-action-btn {
    background: var(--gray);
    border: 1px solid rgba(255, 255, 255, 0.08);
    color: white;
    padding: 6px 12px;
    border-radius: 50px;
    font-size: 11px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-weight: 500;
}

.loop-action-btn:hover { background: rgba(29, 185, 84, 0.15); border-color: var(--primary); }
.loop-action-btn.danger:hover { background: rgba(192, 57, 43, 0.15); border-color: var(--danger); }

.loop-edit-form {
    display: none;
    background: rgba(0, 0, 0, 0.3);
    padding: 16px;
    border-radius: 12px;
    margin-top: 16px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.loop-edit-form.active { display: block; }

.edit-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 16px;
    margin-bottom: 16px;
}

.edit-field {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.edit-label {
    font-size: 12px;
    color: var(--light-gray);
    text-transform: uppercase;
    font-weight: 600;
    letter-spacing: 0.5px;
}

.edit-input {
    background: var(--gray);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 14px;
    font-family: monospace;
}

.edit-input:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(29, 185, 84, 0.1);
}

.edit-actions {
    display: flex;
    gap: 8px;
}

.edit-actions .btn {
    flex: 1;
    padding: 8px 16px;
    font-size: 12px;
}

.loading {
    display: inline-block;
    width: 18px;
    height: 18px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top: 2px solid var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.hidden { display: none !important; }

@media (max-width: 480px) {
    .fine-tune-section {
        padding: 0 15px 20px;
    }

    .precision-popup-content {
    background: linear-gradient(15deg, var(--dark), rgba(42, 42, 42, 0.85));
    /*border: 1px solid rgba(255, 255, 255, 0.08);*/
    padding
    margin-top: 165px;

    }

}

@keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(0.9); }
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-6px); }
}
    </style>
</head>
<body>
    <div class="app-header">
        <div class="header-content">
            <div class="logo">LOOOPZ</div>
            <div class="connection-status" id="connection-status">
                <div class="status-dot"></div>
                <span>Connected</span>
                <button class="disconnect-btn" id="disconnect-btn">Disconnect</button>
            </div>
        </div>
    </div>

    <div class="status-bar" id="status-bar">
        <span id="status-text">Ready</span>
    </div>

    <div class="now-playing-indicator" id="now-playing-indicator">
        <div id="mini-track-title">Now Playing</div>
        <div style="font-size: 10px; opacity: 0.8;" id="mini-track-artist">Artist</div>
    </div>

    <div class="main-container">
        <!-- Login -->
        <div id="login-screen" class="login-screen">
            <div class="login-icon">‚ö°</div>
            <h1 class="login-title">Welcome to LOOOPZ</h1>
            <p class="login-subtitle">Create perfect loops from any Spotify track.<br>Precision timing. Endless possibilities.</p>
            <button class="btn" id="connect-btn">Connect Spotify Premium</button>
            <p style="color: var(--light-gray); font-size: 13px; margin-top: 12px;">Requires Spotify Premium for full track playback</p>
        </div>

        <!-- Search -->
        <div id="search-section" class="hidden">
            <div class="card">
                <div class="search-container">
                    <div class="search-header" id="search-header">
                        <button class="back-btn hidden" id="search-back-btn">‚Üê</button>
                        <input type="text" class="search-input" id="search-input" placeholder="Search for any song..." autocomplete="off">
                    </div>
                </div>
                <div id="search-results">
                    <div style="text-align: center; padding: 40px; color: var(--light-gray);">Search for tracks to start creating loops</div>
                </div>
            </div>
        </div>

        <!-- Player -->
        <div id="player-section" class="hidden">
            <div class="card">
                <div class="now-playing">
                    <div class="current-track" id="current-track">No track selected</div>
                    <div class="current-artist" id="current-artist"></div>
                </div>

                <div class="progress-container" id="progress-container">
                    <div class="loop-region" id="loop-region"></div>
                    <div class="progress-bar" id="progress-bar"></div>
                    <div class="loop-handle start" id="loop-start-handle">
                        <div class="time-popup" id="start-popup">0:00.000</div>
                    </div>
                    <div class="loop-handle end" id="loop-end-handle">
                        <div class="time-popup" id="end-popup">0:30.000</div>
                    </div>
                </div>

                <div class="time-display">
                    <span id="current-time">0:00.000</span>
                    <span id="duration">0:00.000</span>
                </div>

                <div class="main-controls">
                    <div class="playback-controls">
                        <button class="control-btn" id="backward-btn">‚è™</button>
                        <button class="control-btn play-pause-btn" id="play-pause-btn">‚ñ∂</button>
                        <button class="control-btn" id="forward-btn">‚è©</button>
                    </div>

                    <div class="loop-controls">
                        <div class="loop-section">
                            <span>Loop Mode</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="loop-toggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>

                        <div class="loop-section">
                            <span>Repeat Count</span>
                            <div class="repeat-counter">
                                <div class="repeat-btn" id="repeat-decrease">‚àí</div>
                                <div class="repeat-value" id="repeat-value">1√ó</div>
                                <div class="repeat-btn" id="repeat-increase">+</div>
                            </div>
                        </div>

                        <div class="loop-actions">
                            <button class="btn start-loop-btn" id="start-loop-btn">Start Loop</button>
                            <button class="btn secondary" id="save-loop-btn">Save Loop</button>
                            <button class="btn" id="precision-btn" style="background: linear-gradient(135deg, #444, #333); padding: 10px 16px;">‚öôÔ∏è Precision</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Library -->
        <div id="library-section" class="hidden">
            <div class="card">
                <h2 class="card-title">
                    <span>My Saved Loops</span>
                    <button class="btn danger" id="clear-all-loops" style="padding: 6px 12px; font-size: 12px;">Clear All</button>
                </h2>
                <div id="loops-list">
                    <div style="text-align: center; padding: 60px 20px;">
                        <div style="font-size: 48px; margin-bottom: 16px; opacity: 0.4;">üì¶</div>
                        <div style="color: var(--light-gray); font-size: 16px; margin-bottom: 8px;">No saved loops yet</div>
                        <div style="color: var(--light-gray); font-size: 13px;">Create and save loops to build your collection</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Precision Controls Popup -->
    <div class="precision-popup hidden" id="precision-popup">
        <div class="precision-popup-content">
            <div class="precision-popup-header">
                <h3>Precision Controls</h3>
                <button class="popup-close" id="precision-close">‚úï</button>
            </div>

            <div class="precision-inputs">
                <div class="precision-field">
                    <label class="precision-label">Start Time</label>
                    <input type="text" class="precision-input" id="precision-start" placeholder="0:00.000">
                </div>
                <div class="precision-field">
                    <label class="precision-label">End Time</label>
                    <input type="text" class="precision-input" id="precision-end" placeholder="0:30.000">
                </div>
            </div>

            <div class="fine-tune-section">
                <div class="fine-tune-controls">
                    <div class="fine-tune-group">
                        <div class="fine-tune-title">Start Loop</div>
                        <div class="fine-tune-row">
                            <button class="fine-tune-btn" data-target="start" data-amount="-1">-1s</button>
                            <button class="fine-tune-btn" data-target="start" data-amount="1">+1s</button>
                        </div>
                        <div class="fine-tune-row">
                            <button class="fine-tune-btn" data-target="start" data-amount="-0.1">-100ms</button>
                            <button class="fine-tune-btn" data-target="start" data-amount="0.1">+100ms</button>
                        </div>
                    </div>
                    <div class="fine-tune-group">
                        <div class="fine-tune-title">End Loop</div>
                        <div class="fine-tune-row">
                            <button class="fine-tune-btn" data-target="end" data-amount="-1">-1s</button>
                            <button class="fine-tune-btn" data-target="end" data-amount="1">+1s</button>
                        </div>
                        <div class="fine-tune-row">
                            <button class="fine-tune-btn" data-target="end" data-amount="-0.1">-100ms</button>
                            <button class="fine-tune-btn" data-target="end" data-amount="0.1">+100ms</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="mobile-nav">
        <div class="nav-container">
            <button class="nav-btn" id="nav-search">
                <div class="nav-icon">üîç</div>
                <div class="nav-label">Search</div>
            </button>
            <button class="nav-btn" id="nav-player">
                <div class="nav-icon">‚ñ∂</div>
                <div class="nav-label">Player</div>
            </button>
            <button class="nav-btn" id="nav-library">
                <div class="nav-icon">üìö</div>
                <div class="nav-label">Library</div>
                <span class="loop-count-badge" id="loop-count-badge">0</span>
            </button>
            <button class="nav-btn" id="nav-discovery">
            <div class="nav-icon">üí¨</div>
            <div class="nav-label">Discovery</div>
            </button>
        </div>
    </div>



    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    <script>
// SPOTIFY INTEGRATION - CLEANED UP VERSION

// Config
const SPOTIFY_CLIENT_ID = '46637d8f5adb41c0a4be34e0df0c1597';
const SPOTIFY_REDIRECT_URI = 'https://looopz.vercel.app/';
const SPOTIFY_SCOPES = 'streaming user-read-email user-read-private user-read-playback-state user-modify-playback-state';

// State
let spotifyPlayer = null, spotifyDeviceId = null, spotifyAccessToken = null;
let isConnected = false, isPlaying = false, currentTrack = null;
let currentTime = 0, duration = 0, loopStart = 0, loopEnd = 30;
let loopEnabled = false, loopCount = 0, loopTarget = 1, loopStartTime = 0;
let updateTimer = null, savedLoops = [], isLooping = false, isDragging = false;
let currentView = 'login', currentSearchResults = [], currentEditingLoopId = null;

// Search state
let searchState = {
    isSecondLevel: false,
    currentLevel: 'tracks',
    currentEntity: null,
    currentOffset: 0,
    totalTracks: 0,
    hasMore: false,
    query: ''
};

// Long press state - REMOVED
// let longPressTimers = new Map();
// let longPressIntervals = new Map();

// Elements
let els = {};

// Utils
function formatTime(seconds, showMs = true) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    if (showMs) {
        const ms = Math.floor((seconds % 1) * 1000);
        return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    }
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function parseTimeInput(input) {
    if (typeof input === 'number') return input;
    if (!input || typeof input !== 'string') return 0;

    const parts = input.trim().split(':');
    if (parts.length === 2) {
        const minutes = parseInt(parts[0]) || 0;
        const secondsParts = parts[1].split('.');
        const seconds = parseInt(secondsParts[0]) || 0;
        const milliseconds = secondsParts[1] ? parseInt(secondsParts[1].padEnd(3, '0').slice(0, 3)) || 0 : 0;
        return minutes * 60 + seconds + milliseconds / 1000;
    } else {
        const secondsParts = parts[0].split('.');
        const seconds = parseInt(secondsParts[0]) || 0;
        const milliseconds = secondsParts[1] ? parseInt(secondsParts[1].padEnd(3, '0').slice(0, 3)) || 0 : 0;
        return seconds + milliseconds / 1000;
    }
}

function showStatus(message, duration = 3000) {
    els.statusText.textContent = message;
    els.statusBar.classList.add('show');
    setTimeout(() => els.statusBar.classList.remove('show'), duration);
}

function updateProgress() {
    if (!duration) return;
    const percent = (currentTime / duration) * 100;
    els.progressBar.style.width = `${percent}%`;
    els.currentTime.textContent = formatTime(currentTime);
    els.duration.textContent = formatTime(duration);
}

function updatePlayPauseButton() {
    els.playPauseBtn.textContent = isPlaying ? '‚è∏' : '‚ñ∂';
}

function updateNowPlayingIndicator(track = null) {
    const indicator = els.nowPlayingIndicator;
    if (track && isPlaying && currentView !== 'player') {
        els.miniTrackTitle.textContent = track.name;
        els.miniTrackArtist.textContent = track.artist;
        indicator.classList.add('show');
    } else {
        indicator.classList.remove('show');
    }
}

function updateConnectionStatus() {
    els.connectionStatus.classList.toggle('show', isConnected);
}

function updateLoopCountBadge() {
    els.loopCountBadge.textContent = savedLoops.length;
    els.loopCountBadge.style.display = savedLoops.length > 0 ? 'inline-block' : 'none';
}

function updateRepeatDisplay() {
    els.repeatValue.textContent = `${loopTarget}√ó`;
}

function updateLoopVisuals() {
    if (!duration || duration <= 0) return;

    if (loopStart < 0) loopStart = 0;
    if (loopEnd > duration) loopEnd = duration;
    if (loopStart >= loopEnd) {
        loopStart = 0;
        loopEnd = Math.min(30, duration);
    }

    const startPercent = (loopStart / duration) * 100;
    const endPercent = (loopEnd / duration) * 100;

    els.loopStartHandle.style.left = `${startPercent}%`;
    els.loopEndHandle.style.left = `${endPercent}%`;
    els.loopRegion.style.left = `${startPercent}%`;
    els.loopRegion.style.width = `${Math.max(0, endPercent - startPercent)}%`;

    els.startPopup.textContent = formatTime(loopStart);
    els.endPopup.textContent = formatTime(loopEnd);
    els.precisionStart.value = formatTime(loopStart);
    els.precisionEnd.value = formatTime(loopEnd);
}

// Long press functionality
function setupLongPress(element, callback) {
    let isLongPress = false;

    const startLongPress = () => {
        isLongPress = false;
        const timer = setTimeout(() => {
            isLongPress = true;
            element.classList.add('active');
            callback();

            // Start continuous execution
            const interval = setInterval(callback, 150); // Moderate speed
            longPressIntervals.set(element, interval);
        }, 1250); // 1.25 seconds

        longPressTimers.set(element, timer);
    };

    const endLongPress = () => {
        const timer = longPressTimers.get(element);
        const interval = longPressIntervals.get(element);

        if (timer) {
            clearTimeout(timer);
            longPressTimers.delete(element);
        }

        if (interval) {
            clearInterval(interval);
            longPressIntervals.delete(element);
        }

        element.classList.remove('active');

        // If it wasn't a long press, execute once
        if (!isLongPress) {
            callback();
        }
    };

    // Mouse events
    element.addEventListener('mousedown', startLongPress);
    element.addEventListener('mouseup', endLongPress);
    element.addEventListener('mouseleave', endLongPress);

    // Touch events
    element.addEventListener('touchstart', startLongPress, { passive: true });
    element.addEventListener('touchend', endLongPress, { passive: true });
    element.addEventListener('touchcancel', endLongPress, { passive: true });
}

// PKCE Auth
function generateCodeVerifier() {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode(...array)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

async function generateCodeChallenge(verifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    const digest = await crypto.subtle.digest('SHA-256', data);
    return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

async function getSpotifyAuthUrl() {
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    localStorage.setItem('code_verifier', codeVerifier);
    return `https://accounts.spotify.com/authorize?client_id=${SPOTIFY_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(SPOTIFY_REDIRECT_URI)}&scope=${encodeURIComponent(SPOTIFY_SCOPES)}&code_challenge_method=S256&code_challenge=${codeChallenge}&show_dialog=true`;
}

async function connectSpotify() {
    els.connectBtn.innerHTML = '<span class="loading"></span> Connecting...';
    els.connectBtn.disabled = true;
    try {
        const authUrl = await getSpotifyAuthUrl();
        showStatus('Redirecting to Spotify...');
        window.location.href = authUrl;
    } catch (error) {
        showStatus('Connection failed: ' + error.message);
        els.connectBtn.innerHTML = 'Connect Spotify Premium';
        els.connectBtn.disabled = false;
    }
}

async function exchangeCodeForToken(code) {
    const codeVerifier = localStorage.getItem('code_verifier');
    if (!codeVerifier) throw new Error('Code verifier not found');

    const response = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
            grant_type: 'authorization_code',
            code: code,
            redirect_uri: SPOTIFY_REDIRECT_URI,
            client_id: SPOTIFY_CLIENT_ID,
            code_verifier: codeVerifier,
        }),
    });

    const data = await response.json();
    if (data.access_token) {
        spotifyAccessToken = data.access_token;
        localStorage.setItem('spotify_access_token', data.access_token);
        if (data.refresh_token) localStorage.setItem('spotify_refresh_token', data.refresh_token);
        localStorage.removeItem('code_verifier');
        window.history.replaceState({}, document.title, window.location.pathname);
        initializeSpotifyPlayer();
        showStatus('Successfully authenticated!');
    } else {
        throw new Error(data.error_description || 'Token exchange failed');
    }
}

function disconnectSpotify() {
    localStorage.removeItem('spotify_access_token');
    localStorage.removeItem('spotify_refresh_token');
    spotifyAccessToken = null;
    isConnected = false;
    if (spotifyPlayer) spotifyPlayer.disconnect();
    updateConnectionStatus();
    updateNowPlayingIndicator();
    showView('login');
    showStatus('Disconnected from Spotify');
}

// Load track with optional start position
async function loadTrackIntoSpotify(track, startPositionMs = 0) {
    if (!spotifyDeviceId || !spotifyAccessToken) {
        throw new Error('Spotify not ready');
    }

    try {
        console.log('üéµ Loading track:', track.name, 'at position:', startPositionMs);

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile && spotifyPlayer) {
            try {
                await spotifyPlayer.activateElement();
            } catch (e) {
                console.log('üì± Mobile activation:', e.message);
            }
        }

        const response = await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${spotifyDeviceId}`, {
            method: 'PUT',
            body: JSON.stringify({
                uris: [track.uri],
                position_ms: startPositionMs
            }),
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${spotifyAccessToken}`
            },
        });

        if (!response.ok) {
            throw new Error(`Load failed: ${response.status}`);
        }

        let synced = false;
        let attempts = 0;

        while (!synced && attempts < 8) {
            await new Promise(resolve => setTimeout(resolve, 200));
            try {
                const state = await spotifyPlayer.getCurrentState();
                if (state && state.track_window?.current_track) {
                    console.log('‚úÖ SDK synced with track:', state.track_window.current_track.name);
                    synced = true;
                    isPlaying = !state.paused;
                    currentTime = state.position / 1000;
                    duration = state.track_window.current_track.duration_ms / 1000;
                }
            } catch (e) {
                console.log(`‚è≥ Sync attempt ${attempts + 1} failed`);
            }
            attempts++;
        }

        if (!synced) {
            console.warn('‚ö†Ô∏è SDK sync incomplete, but track should be loaded');
        }

        console.log('‚úÖ Track loaded and ready for SDK control');
        return true;

    } catch (error) {
        console.error('üö® Track loading error:', error);
        throw error;
    }
}

// Fast play/pause with smart fallbacks
async function togglePlayPause() {
    if (!currentTrack) {
        showStatus('No track selected');
        return;
    }

    try {
        if (spotifyPlayer) {
            if (isPlaying) {
                await spotifyPlayer.pause();
                console.log('‚è∏ SDK pause success');
            } else {
                await spotifyPlayer.resume();
                console.log('‚ñ∂ SDK resume success');
            }

            isPlaying = !isPlaying;
            updatePlayPauseButton();
            updateNowPlayingIndicator(isPlaying ? currentTrack : null);

            if (isPlaying) {
                startProgressUpdates();
                showStatus('Playing!');
            } else {
                stopProgressUpdates();
                showStatus('Paused');
            }
            return;
        }
    } catch (sdkError) {
        console.log('‚ö†Ô∏è SDK control failed, trying Web API:', sdkError.message);
    }

    try {
        if (isPlaying) {
            await fetch(`https://api.spotify.com/v1/me/player/pause?device_id=${spotifyDeviceId}`, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
            });
        } else {
            await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${spotifyDeviceId}`, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
            });
        }

        isPlaying = !isPlaying;
        updatePlayPauseButton();
        updateNowPlayingIndicator(isPlaying ? currentTrack : null);

        if (isPlaying) {
            startProgressUpdates();
            showStatus('Playing!');
        } else {
            stopProgressUpdates();
            showStatus('Paused');
        }

    } catch (apiError) {
        console.error('üö® Both SDK and API failed:', apiError);
        showStatus('Playback control failed');
    }
}

// Fast positioning
async function playFromPosition(positionMs = 0) {
    if (!currentTrack) {
        showStatus('No track selected');
        return;
    }

    try {
        if (spotifyPlayer) {
            await spotifyPlayer.seek(positionMs);
            if (!isPlaying) {
                await spotifyPlayer.resume();
            }

            isPlaying = true;
            currentTime = positionMs / 1000;
            updatePlayPauseButton();
            updateNowPlayingIndicator(currentTrack);
            updateProgress();
            startProgressUpdates();
            showStatus('Playing!');
            console.log('‚úÖ SDK play from position success');
            return;
        }
    } catch (sdkError) {
        console.log('‚ö†Ô∏è SDK seek/play failed, using Web API:', sdkError.message);
    }

    try {
        await fetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${positionMs}&device_id=${spotifyDeviceId}`, {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
        });

        if (!isPlaying) {
            await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${spotifyDeviceId}`, {
                method: 'PUT',
                headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
            });
        }

        isPlaying = true;
        currentTime = positionMs / 1000;
        updatePlayPauseButton();
        updateNowPlayingIndicator(currentTrack);
        updateProgress();
        startProgressUpdates();
        showStatus('Playing!');

    } catch (apiError) {
        showStatus('Failed to play from position');
    }
}

// Quick seeking
async function seekToPosition(positionMs) {
    try {
        if (spotifyPlayer) {
            await spotifyPlayer.seek(positionMs);
            currentTime = positionMs / 1000;
            updateProgress();
            return;
        }
    } catch (sdkError) {
        console.log('‚ö†Ô∏è SDK seek failed, using API:', sdkError.message);
    }

    try {
        await fetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${positionMs}&device_id=${spotifyDeviceId}`, {
            method: 'PUT',
            headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
        });
        currentTime = positionMs / 1000;
        updateProgress();
    } catch (apiError) {
        showStatus('Seek failed');
    }
}

function initializeSpotifyPlayer() {
    showStatus('Connecting to Spotify...');

    window.onSpotifyWebPlaybackSDKReady = () => {
        spotifyPlayer = new Spotify.Player({
            name: 'LOOOPZ Player',
            getOAuthToken: cb => cb(spotifyAccessToken),
            volume: 0.8
        });

        spotifyPlayer.addListener('initialization_error', ({ message }) => showStatus('Failed to initialize: ' + message));
        spotifyPlayer.addListener('authentication_error', ({ message }) => {
            localStorage.removeItem('spotify_access_token');
            showView('login');
            showStatus('Authentication failed. Please reconnect.');
        });
        spotifyPlayer.addListener('account_error', ({ message }) => showStatus('Spotify Premium required'));
        spotifyPlayer.addListener('playback_error', ({ message }) => showStatus('Playback error: ' + message));

        spotifyPlayer.addListener('ready', ({ device_id }) => {
            console.log('üéµ Spotify player ready with Device ID:', device_id);
            spotifyDeviceId = device_id;
            isConnected = true;
            updateConnectionStatus();
            showView('search');
            showStatus('Connected!');

            setTimeout(() => {
                console.log('üîó Checking for shared loops after connection...');
                const hasSharedData = sessionStorage.getItem('shared_loop');
                if (hasSharedData) {
                    console.log('üîó Found shared loop data, loading...');
                    loadSharedLoop();
                } else {
                    console.log('üîó No shared loop data found');
                }
            }, 1000);
        });

        spotifyPlayer.addListener('not_ready', ({ device_id }) => {
            isConnected = false;
            updateConnectionStatus();
        });

        spotifyPlayer.addListener('player_state_changed', (state) => {
            if (!state) return;

            console.log('üéµ Player state changed - paused:', state.paused, 'position:', state.position);

            currentTime = state.position / 1000;
            isPlaying = !state.paused;

            updateProgress();
            updatePlayPauseButton();
            updateNowPlayingIndicator(currentTrack);

            if (state.track_window.current_track) {
                const track = state.track_window.current_track;
                duration = track.duration_ms / 1000;

                if (currentTrack && currentTrack.uri !== `spotify:track:${track.id}`) {
                    console.log('üîÑ Track changed via Spotify, updating current track');
                    currentTrack.uri = `spotify:track:${track.id}`;
                    currentTrack.name = track.name;
                    currentTrack.artist = track.artists[0].name;
                    currentTrack.duration = duration;

                    els.currentTrack.textContent = track.name;
                    els.currentArtist.textContent = track.artists[0].name;
                }
            }
        });

        spotifyPlayer.connect();
    };

    if (window.Spotify) window.onSpotifyWebPlaybackSDKReady();
}

function startProgressUpdates() {
    stopProgressUpdates();
    updateTimer = setInterval(async () => {
        if (isPlaying && spotifyPlayer && !isLooping) {
            try {
                const state = await spotifyPlayer.getCurrentState();
                if (state && state.position !== undefined) {
                    currentTime = state.position / 1000;
                    updateProgress();
                    if (loopEnabled && currentTime >= loopEnd - 0.1 && loopCount < loopTarget) {
                        const timeSinceLoopStart = Date.now() - loopStartTime;
                        if (timeSinceLoopStart > 800) await handleLoopEnd();
                    }
                }
            } catch (error) {
                console.warn('State check failed:', error.message);
            }
        }
    }, 100);
}

function stopProgressUpdates() {
    if (updateTimer) {
        clearInterval(updateTimer);
        updateTimer = null;
    }
}

async function handleLoopEnd() {
    try {
        isLooping = true;
        loopCount++;

        if (loopCount >= loopTarget) {
            await togglePlayPause();
            showStatus(`Loop completed! Played ${loopTarget} time(s)`);
            loopCount = 0;
        } else {
            showStatus(`Loop ${loopCount + 1}/${loopTarget}`);
            loopStartTime = Date.now();

            try {
                await spotifyPlayer.seek(loopStart * 1000);
                currentTime = loopStart;
                updateProgress();
                console.log('‚úÖ Fast loop seek via SDK');
            } catch (sdkError) {
                console.log('‚ö†Ô∏è SDK loop seek failed, using API:', sdkError.message);
                await fetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${loopStart * 1000}&device_id=${spotifyDeviceId}`, {
                    method: 'PUT',
                    headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
                });
                currentTime = loopStart;
                updateProgress();
            }
        }
    } catch (error) {
        console.error('üö® Loop error:', error);
        showStatus(`Loop error: ${error.message}`);
    } finally {
        isLooping = false;
    }
}

// Enhanced Search with pagination and navigation
async function searchTracks(query) {
    if (!spotifyAccessToken || query.length < 2) return;

    try {
        // Reset search state for new query
        if (query !== searchState.query) {
            searchState = {
                isSecondLevel: false,
                currentLevel: 'tracks',
                currentEntity: null,
                currentOffset: 0,
                totalTracks: 0,
                hasMore: false,
                query: query
            };
        }

        const limit = 10; // Reduced initial limit
        const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=${limit}&offset=${searchState.currentOffset}`, {
            headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
        });

        if (response.status === 401) {
            localStorage.removeItem('spotify_access_token');
            showView('login');
            showStatus('Session expired. Please reconnect.');
            return;
        }

        const data = await response.json();
        const tracks = data.tracks?.items || [];

        // Update search state
        searchState.totalTracks = data.tracks?.total || 0;
        searchState.hasMore = searchState.currentOffset + tracks.length < searchState.totalTracks;

        if (searchState.currentOffset === 0) {
            currentSearchResults = tracks;
        } else {
            currentSearchResults = [...currentSearchResults, ...tracks];
        }

        displaySearchResults(currentSearchResults, searchState.hasMore);
        updateSearchNavigation();

    } catch (error) {
        showStatus('Search failed. Please try again.');
    }
}

async function loadMoreTracks() {
    if (!searchState.hasMore || !searchState.query) return;

    searchState.currentOffset += 10;
    showStatus('Loading more tracks...');
    await searchTracks(searchState.query);
}

function displaySearchResults(tracks, hasMore = false) {
    if (tracks.length === 0) {
        els.searchResults.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--light-gray);">No results found</div>';
        return;
    }

    let html = tracks.map((track, index) => `
        <div class="track-item" data-track-index="${index}">
            <img src="${track.album.images[2]?.url || ''}" alt="Album cover" class="track-cover" onerror="this.style.display='none'">
            <div class="track-info">
                <div class="track-name">${track.name}</div>
                <div class="track-artist">${track.artists[0].name}</div>
            </div>
            <div class="track-duration">${formatTime(track.duration_ms / 1000, false)}</div>
            <div class="track-actions">
                <button class="track-action-btn play-track-btn" data-track-index="${index}">‚ñ∂</button>
                <button class="track-action-btn secondary select-track-btn" data-track-index="${index}">+</button>
            </div>
        </div>
    `).join('');

    // Add load more button if there are more results
    if (hasMore) {
        html += `
            <button class="load-more-btn" id="load-more-tracks">
                Load More Tracks (${searchState.totalTracks - currentSearchResults.length} remaining)
            </button>
        `;
    }

    els.searchResults.innerHTML = html;

    if (currentTrack) updateSearchTrackHighlighting(currentTrack.uri);
}

function updateSearchNavigation() {
    const backBtn = els.searchBackBtn;
    if (searchState.isSecondLevel) {
        backBtn.classList.remove('hidden');
    } else {
        backBtn.classList.add('hidden');
    }
}

function goBackToMainSearch() {
    searchState.isSecondLevel = false;
    searchState.currentLevel = 'tracks';
    searchState.currentEntity = null;
    searchState.currentOffset = 0;

    updateSearchNavigation();

    // Re-run the current search
    if (searchState.query) {
        searchTracks(searchState.query);
    }
}

function updateSearchTrackHighlighting(uri, isSelected = false) {
    document.querySelectorAll('.track-item').forEach(item => {
        item.classList.remove('playing', 'selected');
    });

    if (uri && currentSearchResults) {
        const trackIndex = currentSearchResults.findIndex(track => track.uri === uri);
        if (trackIndex !== -1) {
            const trackElement = document.querySelector(`[data-track-index="${trackIndex}"]`);
            if (trackElement) {
                if (isSelected) {
                    trackElement.classList.add('selected');
                } else if (isPlaying) {
                    trackElement.classList.add('playing');
                }
            }
        }
    }
}

// Background play without navigation
async function playTrackInBackground(track) {
    try {
        showStatus('üéµ Loading track...');

        currentTrack = {
            uri: track.uri,
            name: track.name,
            artist: track.artists[0].name,
            duration: track.duration_ms / 1000,
            image: track.album.images[0]?.url || ''
        };

        duration = currentTrack.duration;

        await loadTrackIntoSpotify(currentTrack);

        updateSearchTrackHighlighting(track.uri);
        updateNowPlayingIndicator(currentTrack);
        showStatus(`üéµ Playing: ${track.name}`);

    } catch (error) {
        console.error('üö® Background play error:', error);
        showStatus('Failed to play track');
    }
}

// Track selection with faster loading
async function selectTrack(uri, name, artist, durationMs, imageUrl) {
    try {
        showStatus('üéµ Loading selected track...');

        currentTrack = { uri, name, artist, duration: durationMs / 1000, image: imageUrl };
        duration = currentTrack.duration;
        loopStart = 0;
        loopEnd = Math.min(30, duration);

        els.currentTrack.textContent = name;
        els.currentArtist.textContent = artist;

        await loadTrackIntoSpotify(currentTrack);

        if (isPlaying) {
            await togglePlayPause();
        }

        updateLoopVisuals();
        updateProgress();
        showView('player');
        showStatus(`‚úÖ Selected: ${name}`);

    } catch (error) {
        console.error('üö® Track selection error:', error);
        showStatus('Failed to load track');
    }
}

// Views
function showView(view) {
    currentView = view;

    els.loginScreen.classList.add('hidden');
    els.searchSection.classList.add('hidden');
    els.playerSection.classList.add('hidden');
    els.librarySection.classList.add('hidden');

    if (view === 'login') els.loginScreen.classList.remove('hidden');
    if (view === 'search') els.searchSection.classList.remove('hidden');
    if (view === 'player') els.playerSection.classList.remove('hidden');
    if (view === 'library') els.librarySection.classList.remove('hidden');

    document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
    const navBtn = document.getElementById(`nav-${view}`);
    if (navBtn) navBtn.classList.add('active');

    if (view === 'library') {
        loadSavedLoops();
        renderLoopsList();
    }
}

// Loop Handles
function setupLoopHandles() {
    let dragTarget = null;

    function startDrag(e, target) {
        isDragging = true;
        dragTarget = target;
        target.classList.add('dragging');
        const popup = target.querySelector('.time-popup');
        if (popup) popup.classList.add('show');
        if (e.preventDefault) e.preventDefault();
        if (e.stopPropagation) e.stopPropagation();
    }

    function updateDrag(e) {
        if (!isDragging || !dragTarget || !duration) return;
        if (e.preventDefault) e.preventDefault();

        const rect = els.progressContainer.getBoundingClientRect();
        const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
        const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        const newTime = percent * duration;

        if (dragTarget === els.loopStartHandle) {
            const maxStart = Math.max(0, loopEnd - 0.1);
            loopStart = Math.max(0, Math.min(newTime, maxStart));
            els.startPopup.textContent = formatTime(loopStart);
        } else if (dragTarget === els.loopEndHandle) {
            const minEnd = Math.min(duration, loopStart + 0.1);
            loopEnd = Math.max(minEnd, Math.min(newTime, duration));
            els.endPopup.textContent = formatTime(loopEnd);
        }

        updateLoopVisuals();
    }

    function stopDrag(e) {
        if (isDragging && dragTarget) {
            dragTarget.classList.remove('dragging');
            const popup = dragTarget.querySelector('.time-popup');
            if (popup) setTimeout(() => popup.classList.remove('show'), 500);
            isDragging = false;
            dragTarget = null;
            if (e && e.preventDefault) e.preventDefault();
        }
    }

    els.loopStartHandle.addEventListener('mousedown', (e) => startDrag(e, els.loopStartHandle));
    els.loopEndHandle.addEventListener('mousedown', (e) => startDrag(e, els.loopEndHandle));
    document.addEventListener('mousemove', updateDrag);
    document.addEventListener('mouseup', stopDrag);

    els.loopStartHandle.addEventListener('touchstart', (e) => startDrag(e.touches[0], els.loopStartHandle), { passive: false });
    els.loopEndHandle.addEventListener('touchstart', (e) => startDrag(e.touches[0], els.loopEndHandle), { passive: false });
    document.addEventListener('touchmove', (e) => { if (isDragging && e.touches[0]) updateDrag(e.touches[0]); }, { passive: false });
    document.addEventListener('touchend', stopDrag, { passive: false });
}

// Loops Management
function loadSavedLoops() {
    try {
        const sessionData = sessionStorage.getItem('looopz_saved_loops');
        if (sessionData && !localStorage.getItem('looopz_saved_loops')) {
            localStorage.setItem('looopz_saved_loops', sessionData);
            sessionStorage.removeItem('looopz_saved_loops');
            showStatus('‚úÖ Restored your saved loops!');
        }

        const saved = localStorage.getItem('looopz_saved_loops');
        savedLoops = saved ? JSON.parse(saved) : [];
        updateLoopCountBadge();
    } catch (error) {
        savedLoops = [];
    }
}

function saveLooopsToStorage() {
    try {
        localStorage.setItem('looopz_saved_loops', JSON.stringify(savedLoops));
        updateLoopCountBadge();
    } catch (error) {
        showStatus('Error saving loops');
    }
}

async function saveCurrentLoop() {
    if (!currentTrack) {
        showStatus('No track selected to save');
        return;
    }

    const existingLoop = savedLoops.find(l =>
        l.track.uri === currentTrack.uri &&
        Math.abs(l.loop.start - loopStart) < 0.1 &&
        Math.abs(l.loop.end - loopEnd) < 0.1 &&
        l.loop.repeat === loopTarget
    );

    if (existingLoop) {
        showStatus('This exact loop is already saved');
        return;
    }

    const loop = {
        id: `loop_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        track: {
            uri: currentTrack.uri,
            name: currentTrack.name,
            artist: currentTrack.artist,
            duration: currentTrack.duration,
            image: currentTrack.image
        },
        loop: { start: loopStart, end: loopEnd, repeat: loopTarget },
        savedAt: new Date().toISOString(),
        playCount: 0
    };

    savedLoops.unshift(loop);
    saveLooopsToStorage();

    const saveBtn = els.saveLoopBtn;
    const originalText = saveBtn.innerHTML;
    saveBtn.innerHTML = 'Saved!';
    saveBtn.style.background = 'linear-gradient(135deg, #27ae60, #22c55e)';

    setTimeout(() => {
        saveBtn.innerHTML = originalText;
        saveBtn.style.background = '';
    }, 2000);

    showStatus(`Loop saved! Total: ${savedLoops.length}`);
}

function renderLoopsList() {
    if (savedLoops.length === 0) {
        els.loopsList.innerHTML = `
            <div style="text-align: center; padding: 60px 20px;">
                <div style="font-size: 48px; margin-bottom: 16px; opacity: 0.4;">üì¶</div>
                <div style="color: var(--light-gray); font-size: 16px; margin-bottom: 8px;">No saved loops yet</div>
                <div style="color: var(--light-gray); font-size: 13px;">Create and save loops to build your collection</div>
            </div>
        `;
        return;
    }

    els.loopsList.innerHTML = savedLoops.map((loop, index) => `
        <div class="saved-loop" data-loop-id="${loop.id}">
            <div class="loop-header">
                <img src="${loop.track.image || ''}" alt="${loop.track.name}" class="loop-thumbnail" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 60 60\"%3E%3Crect width=\"60\" height=\"60\" fill=\"%23333\"/%3E%3C/svg%3E'">
                <div class="loop-details">
                    <div class="loop-track-name">${loop.track.name}</div>
                    <div class="loop-artist">${loop.track.artist}</div>
                </div>
            </div>

            <div class="loop-stats">
                <div class="loop-stat">
                    <span class="loop-stat-icon">‚è±</span>
                    <span>${formatTime(loop.loop.start, false)} - ${formatTime(loop.loop.end, false)}</span>
                </div>
                <div class="loop-stat">
                    <span class="loop-stat-icon">üîÑ</span>
                    <span>${loop.loop.repeat}√ó</span>
                </div>
                <div class="loop-stat">
                    <span class="loop-stat-icon">üìÖ</span>
                    <span>${new Date(loop.savedAt).toLocaleDateString()}</span>
                </div>
            </div>

            <div class="loop-actions">
                <button class="loop-action-btn load-btn" data-loop-id="${loop.id}">Load</button>
                <button class="loop-action-btn edit-btn" data-loop-id="${loop.id}">Edit</button>
                <button class="loop-action-btn share-btn" data-loop-id="${loop.id}">Share</button>
                <button class="loop-action-btn danger delete-btn" data-loop-id="${loop.id}">Delete</button>
            </div>

            <div class="loop-edit-form" id="edit-form-${loop.id}">
                <div class="edit-grid">
                    <div class="edit-field">
                        <label class="edit-label">Start Time</label>
                        <input type="text" class="edit-input" id="edit-start-${loop.id}" value="${formatTime(loop.loop.start)}">
                    </div>
                    <div class="edit-field">
                        <label class="edit-label">End Time</label>
                        <input type="text" class="edit-input" id="edit-end-${loop.id}" value="${formatTime(loop.loop.end)}">
                    </div>
                    <div class="edit-field">
                        <label class="edit-label">Repeat Count</label>
                        <input type="number" class="edit-input" id="edit-repeat-${loop.id}" value="${loop.loop.repeat}" min="1" max="99">
                    </div>
                </div>
                <div class="edit-actions">
                    <button class="btn secondary" onclick="saveLoopEdits('${loop.id}')">üíæ Save</button>
                    <button class="btn" onclick="cancelEdit('${loop.id}')">‚ùå Cancel</button>
                </div>
            </div>
        </div>
    `).join('');
}

// Library loop loading - starts from loop start position
async function loadSavedLoop(loopId) {
    const loop = savedLoops.find(l => l.id === loopId);
    if (!loop) {
        showStatus('Loop not found');
        return;
    }

    try {
        showStatus('üîÑ Loading saved loop...');

        loop.playCount = (loop.playCount || 0) + 1;
        saveLooopsToStorage();

        currentTrack = {
            uri: loop.track.uri,
            name: loop.track.name,
            artist: loop.track.artist,
            duration: loop.track.duration,
            image: loop.track.image || ''
        };

        duration = currentTrack.duration;
        els.currentTrack.textContent = loop.track.name;
        els.currentArtist.textContent = loop.track.artist;

        loopStart = loop.loop.start;
        loopEnd = loop.loop.end;
        loopTarget = loop.loop.repeat;
        loopEnabled = true;

        if (els.loopToggle) els.loopToggle.checked = true;
        updateRepeatDisplay();
        updateLoopVisuals();

        await loadTrackIntoSpotify(currentTrack, loopStart * 1000);

        loopCount = 0;
        loopStartTime = Date.now();

        updateProgress();
        updatePlayPauseButton();
        updateNowPlayingIndicator(currentTrack);
        startProgressUpdates();

        showView('player');
        showStatus(`üîÑ Loop playing: ${loop.track.name} (1/${loopTarget})`);

    } catch (error) {
        console.error('üö® Load saved loop error:', error);
        showStatus('Failed to load loop');
    }
}

function editLoop(loopId) {
    document.querySelectorAll('.loop-edit-form').forEach(form => form.classList.remove('active'));
    const editForm = document.getElementById(`edit-form-${loopId}`);
    if (editForm) {
        editForm.classList.add('active');
        currentEditingLoopId = loopId;
    }
}

function cancelEdit(loopId) {
    const editForm = document.getElementById(`edit-form-${loopId}`);
    if (editForm) editForm.classList.remove('active');
    currentEditingLoopId = null;
}

function saveLoopEdits(loopId) {
    const loop = savedLoops.find(l => l.id === loopId);
    if (!loop) return;

    const newStart = parseTimeInput(document.getElementById(`edit-start-${loopId}`).value);
    const newEnd = parseTimeInput(document.getElementById(`edit-end-${loopId}`).value);
    const newRepeat = parseInt(document.getElementById(`edit-repeat-${loopId}`).value);

    if (newStart < 0 || newStart >= loop.track.duration || newEnd <= newStart || newEnd > loop.track.duration || newRepeat < 1 || newRepeat > 99) {
        showStatus('‚ùå Invalid values');
        return;
    }

    loop.loop.start = newStart;
    loop.loop.end = newEnd;
    loop.loop.repeat = newRepeat;
    saveLooopsToStorage();
    renderLoopsList();
    currentEditingLoopId = null;
    showStatus('‚úÖ Loop updated!');
}

// Share button with Web Share API + Open Graph
async function shareSavedLoop(loopId, shareBtn = null) {
    const loop = savedLoops.find(l => l.id === loopId);
    if (!loop) return;

    if (!shareBtn) {
        shareBtn = document.querySelector(`.share-btn[data-loop-id="${loopId}"]`);
    }

    try {
        if (shareBtn) {
            shareBtn.innerHTML = 'Sharing...';
            shareBtn.style.background = '#f39c12';
            shareBtn.style.color = 'white';
            shareBtn.disabled = true;
        }

        const shareData = {
            track: loop.track.uri,
            start: loop.loop.start.toFixed(1),
            end: loop.loop.end.toFixed(1),
            repeat: loop.loop.repeat,
            name: encodeURIComponent(loop.track.name),
            artist: encodeURIComponent(loop.track.artist)
        };

        const loopUrl = `${window.location.origin}${window.location.pathname}?${new URLSearchParams(shareData).toString()}`;

        // Update Open Graph meta tags
        document.querySelector('meta[property="og:title"]').content = `üéµ ${loop.track.name} - Loop`;
        document.querySelector('meta[property="og:description"]').content = `Perfect loop: ${formatTime(loop.loop.start)} ‚Üí ${formatTime(loop.loop.end)} (${loop.loop.repeat}√ó) | Created with LOOOPZ`;
        document.querySelector('meta[property="og:url"]').content = loopUrl;

        // Create formatted share content
        const repeatText = loop.loop.repeat > 1 ? ` (${loop.loop.repeat}√ó)` : '';
        const shareText = `üéµ Check out this perfect loop I created!

üé§ "${loop.track.name}"
üë®‚Äçüé§ ${loop.track.artist}
‚è±Ô∏è ${formatTime(loop.loop.start)} ‚Üí ${formatTime(loop.loop.end)}${repeatText}

üîó Play it here:`;

        // Try Web Share API first
        if (navigator.share && navigator.canShare && navigator.canShare({ url: loopUrl })) {
            await navigator.share({
                title: `üéµ ${loop.track.name} - Loop`,
                text: shareText,
                url: loopUrl
            });

            if (shareBtn) {
                shareBtn.innerHTML = 'Shared!';
                shareBtn.style.background = 'linear-gradient(135deg, #27ae60, #22c55e)';
            }
            showStatus('üîó Loop shared successfully!');
        } else {
            // Fallback to clipboard with formatted content
            const fullShareContent = `${shareText}\n${loopUrl}`;
            await navigator.clipboard.writeText(fullShareContent);

            if (shareBtn) {
                shareBtn.innerHTML = 'Copied!';
                shareBtn.style.background = 'linear-gradient(135deg, #27ae60, #22c55e)';
            }
            showStatus('üîó Formatted loop content copied to clipboard!');
        }

        setTimeout(() => {
            if (shareBtn) {
                shareBtn.innerHTML = 'Share';
                shareBtn.style.background = '';
                shareBtn.style.color = '';
                shareBtn.disabled = false;
            }
        }, 3000);

    } catch (err) {
        console.error('Share error:', err);
        showStatus('Failed to share loop');

        if (shareBtn) {
            shareBtn.innerHTML = 'Share';
            shareBtn.style.background = '';
            shareBtn.style.color = '';
            shareBtn.disabled = false;
        }
    }
}

function deleteLoop(loopId) {
    if (!confirm('Delete this loop?')) return;
    savedLoops = savedLoops.filter(l => l.id !== loopId);
    saveLooopsToStorage();
    renderLoopsList();
    showStatus('üóëÔ∏è Loop deleted');
}

function clearAllLoops() {
    if (!confirm('Clear all loops?')) return;
    savedLoops = [];
    saveLooopsToStorage();
    renderLoopsList();
    showStatus('üóëÔ∏è All loops cleared');
}

// Shared Loops
function checkForSharedLoop() {
    const urlParams = new URLSearchParams(window.location.search);
    const sharedTrack = urlParams.get('track');
    const sharedStart = urlParams.get('start');
    const sharedEnd = urlParams.get('end');
    const sharedRepeat = urlParams.get('repeat');
    const sharedName = urlParams.get('name');
    const sharedArtist = urlParams.get('artist');

    console.log('üîó Checking for shared loop...', { sharedTrack, sharedStart, sharedEnd });

    if (sharedTrack && sharedStart && sharedEnd) {
        console.log('üîó Found shared loop in URL!');

        const sharedLoop = {
            track: sharedTrack,
            start: parseFloat(sharedStart),
            end: parseFloat(sharedEnd),
            repeat: parseInt(sharedRepeat) || 1,
            name: sharedName ? decodeURIComponent(sharedName) : null,
            artist: sharedArtist ? decodeURIComponent(sharedArtist) : null
        };

        sessionStorage.setItem('shared_loop', JSON.stringify(sharedLoop));
        console.log('üîó Stored shared loop data:', sharedLoop);

        if (isConnected && spotifyAccessToken) {
            console.log('üîó Already connected, loading shared loop...');
            setTimeout(() => loadSharedLoop(), 1000);
        } else {
            console.log('üîó Not connected, showing preview...');
            showSharedLoopPreview(sharedLoop);
        }

        return true;
    }
    return false;
}

function showSharedLoopPreview(sharedLoop) {
    showView('login');
    const loginSubtitle = document.querySelector('.login-subtitle');
    if (loginSubtitle && sharedLoop.name && sharedLoop.artist) {
        const repeatText = sharedLoop.repeat > 1 ? ` (${sharedLoop.repeat}√ó)` : '';
        loginSubtitle.innerHTML = `
            <div style="background: linear-gradient(135deg, rgba(29, 185, 84, 0.2), rgba(153, 69, 219, 0.2));
                        padding: 20px; border-radius: 16px; border: 1px solid rgba(29, 185, 84, 0.3);
                        margin-bottom: 20px;">
                <div style="font-size: 16px; color: var(--primary); margin-bottom: 8px;">
                    üîó Someone shared a loop with you!
                </div>
                <div style="font-size: 18px; font-weight: 600; margin-bottom: 4px;">
                    "${sharedLoop.name}"
                </div>
                <div style="color: var(--light-gray); margin-bottom: 8px;">
                    by ${sharedLoop.artist}
                </div>
                <div style="font-size: 14px; color: var(--light-gray);">
                    Loop: ${formatTime(sharedLoop.start)} - ${formatTime(sharedLoop.end)}${repeatText}
                </div>
            </div>
            <div style="color: var(--light-gray); font-size: 16px;">
                Connect Spotify to play this loop instantly!
            </div>
        `;
    }
}

// Shared loop loading
async function loadSharedLoop() {
    const sharedLoopData = sessionStorage.getItem('shared_loop');
    if (!sharedLoopData) {
        console.log('üîó No shared loop data found');
        return;
    }

    try {
        const sharedLoop = JSON.parse(sharedLoopData);
        console.log('üîó Loading shared loop:', sharedLoop);

        showStatus('üîó Loading shared loop...');

        const trackId = sharedLoop.track.split(':')[2];
        if (!trackId) {
            throw new Error('Invalid track URI format');
        }

        const response = await fetch(`https://api.spotify.com/v1/tracks/${trackId}`, {
            headers: { 'Authorization': `Bearer ${spotifyAccessToken}` }
        });

        if (!response.ok) {
            throw new Error(`Failed to load track: ${response.status}`);
        }

        const track = await response.json();
        console.log('üîó Track loaded:', track.name);

        const choice = await showSharedLoopDialog(track, sharedLoop);

        if (choice === 'cancel') {
            sessionStorage.removeItem('shared_loop');
            cleanupSharedUrl();
            return;
        }

        if (choice === 'load') {
            currentTrack = {
                uri: track.uri,
                name: track.name,
                artist: track.artists[0].name,
                duration: track.duration_ms / 1000,
                image: track.album.images[0]?.url || ''
            };

            duration = currentTrack.duration;
            els.currentTrack.textContent = track.name;
            els.currentArtist.textContent = track.artists[0].name;

            loopStart = sharedLoop.start;
            loopEnd = sharedLoop.end;
            loopTarget = sharedLoop.repeat;
            loopEnabled = true;

            if (els.loopToggle) els.loopToggle.checked = true;
            updateRepeatDisplay();
            updateLoopVisuals();

            await loadTrackIntoSpotify(currentTrack, loopStart * 1000);

            loopCount = 0;
            loopStartTime = Date.now();

            updateProgress();
            updatePlayPauseButton();
            updateNowPlayingIndicator(currentTrack);
            startProgressUpdates();

            showView('player');
        }

        sessionStorage.removeItem('shared_loop');
        cleanupSharedUrl();

        const repeatText = sharedLoop.repeat > 1 ? ` (${sharedLoop.repeat}√ó)` : '';
        showStatus(`üîó Shared loop loaded: "${track.name}" (${formatTime(sharedLoop.start)} - ${formatTime(sharedLoop.end)}${repeatText})`);

    } catch (error) {
        console.error('üîó Error loading shared track:', error);
        showStatus('‚ùå Failed to load shared loop');
        sessionStorage.removeItem('shared_loop');
        cleanupSharedUrl();
    }
}

async function showSharedLoopDialog(track, sharedLoop) {
    return new Promise((resolve) => {
        const dialog = document.createElement('div');
        dialog.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 10, 0.95); backdrop-filter: blur(10px);
            z-index: 1001; display: flex; align-items: center; justify-content: center;
        `;

        const repeatText = sharedLoop.repeat > 1 ? ` (${sharedLoop.repeat}√ó)` : '';

        dialog.innerHTML = `
            <div style="background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
                        border: 1px solid rgba(29, 185, 84, 0.3); border-radius: 20px;
                        padding: 30px; max-width: 400px; text-align: center; color: white;">
                <div style="font-size: 24px; margin-bottom: 8px;">üîó Shared Loop</div>
                <div style="font-size: 18px; font-weight: 600; margin-bottom: 4px; color: #1DB954;">
                    "${track.name}"
                </div>
                <div style="color: #b3b3b3; margin-bottom: 8px;">by ${track.artists[0].name}</div>
                <div style="color: #b3b3b3; font-size: 14px; margin-bottom: 20px;">
                    Loop: ${formatTime(sharedLoop.start)} - ${formatTime(sharedLoop.end)}${repeatText}
                </div>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="load-btn" style="background: linear-gradient(135deg, #1DB954, #1ed760);
                                                  color: white; border: none; padding: 12px 24px;
                                                  border-radius: 50px; font-weight: 600; cursor: pointer;">
                        üîÑ Load & Play
                    </button>
                    <button id="cancel-btn" style="background: #444; color: white; border: none;
                                                  padding: 12px 24px; border-radius: 50px;
                                                  font-weight: 600; cursor: pointer;">
                        ‚ùå Cancel
                    </button>
                </div>
            </div>
        `;

        document.body.appendChild(dialog);

        dialog.querySelector('#load-btn').onclick = () => {
            document.body.removeChild(dialog);
            resolve('load');
        };

        dialog.querySelector('#cancel-btn').onclick = () => {
            document.body.removeChild(dialog);
            resolve('cancel');
        };

        dialog.onclick = (e) => {
            if (e.target === dialog) {
                document.body.removeChild(dialog);
                resolve('cancel');
            }
        };
    });
}

function cleanupSharedUrl() {
    const cleanUrl = window.location.origin + window.location.pathname;
    window.history.replaceState({}, document.title, cleanUrl);
    console.log('üîó Cleaned up shared URL');
}

// Enhanced Auth Check
function checkAuth() {
    console.log('üîê Starting auth check...');

    const sessionToken = sessionStorage.getItem('spotify_access_token');
    if (sessionToken && !localStorage.getItem('spotify_access_token')) {
        console.log('üîÑ Migrating auth from sessionStorage...');
        localStorage.setItem('spotify_access_token', sessionToken);
        sessionStorage.removeItem('spotify_access_token');
        const sessionRefresh = sessionStorage.getItem('spotify_refresh_token');
        if (sessionRefresh) {
            localStorage.setItem('spotify_refresh_token', sessionRefresh);
            sessionStorage.removeItem('spotify_refresh_token');
        }
    }

    const hasSharedLoop = checkForSharedLoop();
    console.log('üîó Has shared loop:', hasSharedLoop);

    const storedToken = localStorage.getItem('spotify_access_token');
    if (storedToken && spotifyAccessToken && isConnected && spotifyDeviceId) {
        console.log('üîê Already connected, checking for shared loops...');
        if (hasSharedLoop) {
            setTimeout(() => loadSharedLoop(), 1000);
        }
        return;
    }

    if (storedToken) {
        console.log('üîê Found stored token, validating...');
        spotifyAccessToken = storedToken;
        validateToken(storedToken);
        return;
    }

    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    const error = urlParams.get('error');

    if (error) {
        console.log('üîê Auth error:', error);
        showStatus('Authentication failed: ' + error);
        showView('login');
        return;
    }

    if (code) {
        console.log('üîê Found auth code, exchanging for token...');
        exchangeCodeForToken(code);
        return;
    }

    console.log('üîê No auth found, showing login...');
    showView('login');
}

async function validateToken(token) {
    try {
        const response = await fetch('https://api.spotify.com/v1/me', {
            headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
            initializeSpotifyPlayer();
        } else {
            localStorage.removeItem('spotify_access_token');
            localStorage.removeItem('spotify_refresh_token');
            spotifyAccessToken = null;
            showView('login');
            showStatus('Session expired. Please reconnect.');
        }
    } catch (error) {
        localStorage.removeItem('spotify_access_token');
        localStorage.removeItem('spotify_refresh_token');
        spotifyAccessToken = null;
        showView('login');
        showStatus('Connection error. Please reconnect.');
    }
}

// Enhanced Event Delegation
function setupEventListeners() {
    // Navigation
    els.navSearch.addEventListener('click', (e) => {
        e.preventDefault();
        isConnected ? showView('search') : showView('login');
    });

    els.navPlayer.addEventListener('click', (e) => {
        e.preventDefault();
        if (currentTrack) {
            showView('player');
        } else {
            showStatus('Please select a track first');
            isConnected ? showView('search') : showView('login');
        }
    });

    // ESC key to close popup
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !els.precisionPopup.classList.contains('hidden')) {
            els.precisionPopup.classList.add('hidden');
        }
    });

    els.navLibrary.addEventListener('click', (e) => {
        e.preventDefault();
        showView('library');
    });
    
    els.navDiscovery.addEventListener('click', (e) => {
        e.preventDefault();
        window.location.href = 'discovery.html';
    });

    // Main event delegation
    document.addEventListener('click', async (e) => {
        const target = e.target;

        try {
            // Playback controls
            if (target.matches('#play-pause-btn')) {
                e.preventDefault();
                if (!currentTrack) {
                    showStatus('Please select a track first');
                    return;
                }
                target.disabled = true;
                try {
                    await togglePlayPause();
                } finally {
                    target.disabled = false;
                }
            }
            else if (target.matches('#backward-btn')) {
                e.preventDefault();
                const newTime = Math.max(0, currentTime - 10);
                await seekToPosition(newTime * 1000);
            }
            else if (target.matches('#forward-btn')) {
                e.preventDefault();
                const newTime = Math.min(duration, currentTime + 10);
                await seekToPosition(newTime * 1000);
            }

            // Loop controls - CLEANED UP (removed precision-repeat references)
            else if (target.matches('#start-loop-btn')) {
                e.preventDefault();
                if (!currentTrack || !loopEnabled) {
                    showStatus('Please select a track and enable loop mode');
                    return;
                }
                target.disabled = true;
                try {
                    loopCount = 0;
                    loopStartTime = Date.now();
                    await playFromPosition(loopStart * 1000);
                    showStatus(`Starting loop 1/${loopTarget}`);
                } finally {
                    target.disabled = false;
                }
            }
            else if (target.matches('#repeat-decrease')) {
                e.preventDefault();
                if (loopTarget > 1) {
                    loopTarget--;
                    updateRepeatDisplay();
                    loopCount = 0;
                }
            }
            else if (target.matches('#repeat-increase')) {
                e.preventDefault();
                if (loopTarget < 99) {
                    loopTarget++;
                    updateRepeatDisplay();
                    loopCount = 0;
                }
            }

            // Precision popup
            else if (target.matches('#precision-btn')) {
                e.preventDefault();
                els.precisionPopup.classList.remove('hidden');
            }
            else if (target.matches('#precision-close')) {
                e.preventDefault();
                els.precisionPopup.classList.add('hidden');
            }
            else if (target.matches('.precision-popup') && !target.closest('.precision-popup-content')) {
                e.preventDefault();
                els.precisionPopup.classList.add('hidden');
            }

            // Search navigation
            else if (target.matches('#search-back-btn')) {
                e.preventDefault();
                goBackToMainSearch();
            }

            // Load more
            else if (target.matches('#load-more-tracks')) {
                e.preventDefault();
                target.disabled = true;
                target.innerHTML = 'Loading...';
                try {
                    await loadMoreTracks();
                } finally {
                    target.disabled = false;
                }
            }

            // Auth buttons
            else if (target.matches('#connect-btn')) {
                e.preventDefault();
                connectSpotify();
            }
            else if (target.matches('#disconnect-btn')) {
                e.preventDefault();
                disconnectSpotify();
            }

            // Search results
            else if (target.matches('.play-track-btn')) {
                e.stopPropagation();
                e.preventDefault();
                const index = parseInt(target.dataset.trackIndex);
                const track = currentSearchResults[index];
                if (track) await playTrackInBackground(track);
            }
            else if (target.matches('.select-track-btn')) {
                e.stopPropagation();
                e.preventDefault();
                const index = parseInt(target.dataset.trackIndex);
                const track = currentSearchResults[index];
                if (track) {
                    updateSearchTrackHighlighting(track.uri, true);
                    await selectTrack(track.uri, track.name, track.artists[0].name, track.duration_ms, track.album.images[0]?.url || '');
                }
            }
            else if (target.closest('.track-item') && !target.closest('.track-actions')) {
                e.preventDefault();
                const item = target.closest('.track-item');
                const index = parseInt(item.dataset.trackIndex);
                const track = currentSearchResults[index];
                if (track) {
                    await selectTrack(track.uri, track.name, track.artists[0].name, track.duration_ms, track.album.images[0]?.url || '');
                }
            }

            // Library actions
            else if (target.matches('.load-btn')) {
                e.preventDefault();
                const loopId = target.dataset.loopId;
                await loadSavedLoop(loopId);
            }
            else if (target.matches('.edit-btn')) {
                e.preventDefault();
                const loopId = target.dataset.loopId;
                editLoop(loopId);
            }
            else if (target.matches('.share-btn')) {
                e.preventDefault();
                const loopId = target.dataset.loopId;
                await shareSavedLoop(loopId, target);
            }
            else if (target.matches('.delete-btn')) {
                e.preventDefault();
                const loopId = target.dataset.loopId;
                deleteLoop(loopId);
            }
            else if (target.matches('#save-loop-btn')) {
                e.preventDefault();
                await saveCurrentLoop();
            }
            else if (target.matches('#clear-all-loops')) {
                e.preventDefault();
                clearAllLoops();
            }

            // Progress bar click
            else if (target.matches('#progress-container') || target.closest('#progress-container')) {
                if (isDragging) return;
                if (target.classList.contains('loop-handle') || target.closest('.loop-handle')) return;

                e.preventDefault();
                const rect = els.progressContainer.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                const newTime = percent * duration;
                await seekToPosition(newTime * 1000);
            }
        } catch (error) {
            console.error('üö® Event handler error:', error);
            showStatus('Action failed: ' + error.message);
        }
    });

    // Other specific event listeners
    els.loopToggle.addEventListener('change', function() {
        loopEnabled = this.checked;
        loopCount = 0;
        els.startLoopBtn.disabled = !loopEnabled;
        showStatus(loopEnabled ? `Loop enabled: ${loopTarget} time(s)` : 'Loop disabled');
    });

    els.searchInput.addEventListener('input', function() {
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            // Reset search state for new query
            searchState.currentOffset = 0;
            searchTracks(this.value);
        }, 300);
    });

    els.precisionStart.addEventListener('change', function() {
        const newStart = parseTimeInput(this.value);
        if (newStart >= 0 && newStart < loopEnd && newStart <= duration) {
            loopStart = newStart;
            updateLoopVisuals();
        } else {
            this.value = formatTime(loopStart);
        }
    });

    els.precisionEnd.addEventListener('change', function() {
        const newEnd = parseTimeInput(this.value);
        if (newEnd > loopStart && newEnd <= duration) {
            loopEnd = newEnd;
            updateLoopVisuals();
        } else {
            this.value = formatTime(loopEnd);
        }
    });

    // Fine-tune buttons - simple click only
    document.addEventListener('click', (e) => {
        if (e.target.matches('.fine-tune-btn')) {
            e.preventDefault();
            const targetType = e.target.dataset.target;
            const amount = parseFloat(e.target.dataset.amount);
            if (targetType === 'start') {
                loopStart = Math.max(0, Math.min(loopStart + amount, loopEnd - 0.1));
            } else {
                loopEnd = Math.max(loopStart + 0.1, Math.min(loopEnd + amount, duration));
            }
            updateLoopVisuals();
        }
    });
}

// Global edit functions
window.editLoop = editLoop;
window.cancelEdit = cancelEdit;
window.saveLoopEdits = saveLoopEdits;

// Init
function init() {
    console.log('üöÄ Initializing LOOOPZ - Cleaned Up Version...');

    // Cache all elements - CLEANED UP (removed precisionRepeatValue)
    els = {
        loginScreen: document.getElementById('login-screen'),
        searchSection: document.getElementById('search-section'),
        playerSection: document.getElementById('player-section'),
        librarySection: document.getElementById('library-section'),
        connectBtn: document.getElementById('connect-btn'),
        disconnectBtn: document.getElementById('disconnect-btn'),
        connectionStatus: document.getElementById('connection-status'),
        statusBar: document.getElementById('status-bar'),
        statusText: document.getElementById('status-text'),
        nowPlayingIndicator: document.getElementById('now-playing-indicator'),
        miniTrackTitle: document.getElementById('mini-track-title'),
        miniTrackArtist: document.getElementById('mini-track-artist'),
        searchInput: document.getElementById('search-input'),
        searchResults: document.getElementById('search-results'),
        searchBackBtn: document.getElementById('search-back-btn'),
        currentTrack: document.getElementById('current-track'),
        currentArtist: document.getElementById('current-artist'),
        progressContainer: document.getElementById('progress-container'),
        progressBar: document.getElementById('progress-bar'),
        loopRegion: document.getElementById('loop-region'),
        loopStartHandle: document.getElementById('loop-start-handle'),
        loopEndHandle: document.getElementById('loop-end-handle'),
        startPopup: document.getElementById('start-popup'),
        endPopup: document.getElementById('end-popup'),
        currentTime: document.getElementById('current-time'),
        duration: document.getElementById('duration'),
        playPauseBtn: document.getElementById('play-pause-btn'),
        backwardBtn: document.getElementById('backward-btn'),
        forwardBtn: document.getElementById('forward-btn'),
        startLoopBtn: document.getElementById('start-loop-btn'),
        saveLoopBtn: document.getElementById('save-loop-btn'),
        loopToggle: document.getElementById('loop-toggle'),
        repeatValue: document.getElementById('repeat-value'),
        precisionPopup: document.getElementById('precision-popup'),
        precisionBtn: document.getElementById('precision-btn'),
        precisionClose: document.getElementById('precision-close'),
        precisionStart: document.getElementById('precision-start'),
        precisionEnd: document.getElementById('precision-end'),
        loopsList: document.getElementById('loops-list'),
        loopCountBadge: document.getElementById('loop-count-badge'),
        navSearch: document.getElementById('nav-search'),
        navPlayer: document.getElementById('nav-player'),
        navLibrary: document.getElementById('nav-library')
        navDiscovery: document.getElementById('nav-discovery')
    };

    setupEventListeners();
    setupLoopHandles();
    checkAuth();
    loadSavedLoops();

    console.log('‚úÖ LOOOPZ initialization complete - All cleaned up!');
}

document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', init) : init();
    </script>
</body>
</html>
